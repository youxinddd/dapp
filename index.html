<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="format-detection" content="telephone=no" />
  <title>区块链博客 - Vue + Web3.js</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net"/>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com"/>
  <link rel="icon" type="image/png" href= "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAIGNIUk0AAHomAACAhAAA+gAAAIDoAAB1MAAA6mAAADqYAAAXcJy6UTwAAAAGYktHRAD/AP8A/6C9p5MAAAAHdElNRQfpCBYINzLuXgNkAAAH6ElEQVRIx42WeYydVRnGf++33v3O3Jm5M9PSUqm2It2gUKlUaVNUIgJ/kEhiTMECghgVYxQRkZQEQQkoilGWRFTWmpqohCUQigUpFCgtKh06FEqn05npLHdfvvX1j7ml0CB68n3/nJOc5z3P85z3ORLFMR88BAE/4OAB9rzOvmFGD1KakTf2cPCgnnKq7Bum0KM33sLS5aSSqH7wLh8MIEKjyfPP8uhf5ZWXKM1gGjgOwOQUgCoiiFDo0ZNX8pWLOeMzmCbo/wEgwhtD/OIWeW4bro1hEEXkcqDEyughentwHZotWm0sk3abREq/9V0u2ohh/C8AEQ4ckG9fzmu7SKUo9mGYTEzgByQS+B4IxV6SSWp1DINUkmqNVgvL0Tvu4pOrj+HKOrZ8hc3388rLuC5BwPQMhkGrRRAi0GojwqExDIMwwnVppRDIZpmY4LFHWLX6mP2OARBaTXa+jCr9A7p2PfmuzrEM6cALsz+BLzteYOh1in2YBqbJW2/iebjOh54gCKReJ5nUH1zHF8/nQ4e+s18uu4jxUfqLRLG02hqF4L5X6vdrIqAQhRR6WH7y7MTsh4Iq+v6Zwbl63DxUCSOiCI0R+e8UxcrOHfzlz4yMkMthmFG14Y9PzFLkzuk3Uqmo3vDGJlAFcQeLZsLtGLo9iucxdoidL7N6TYfP9wGI8Nwzct3VdHWDIoaYZvnZ7ftv/a2qGq6z6MZrciuXVXa+NrzpVo1iMWThtVcV1n1K45gwxHE5dRUT4/Kdb+jNt7H+s+966QiAH/Dgfbr4RK7dxNc3SrmscdS99ozM0hMRCQ5PeROTtX8OqerSe29HlSCws2lte0QRUagrT+NXdzH8hlx5CQ/dx5ozcewjGiiIEIYyMcb8BeTz2LZ+7mzy3UY66c6fm5g3x0gkarv+1Rwabux9KzF/rnv8cU5lmttu1lde4oxPk0yRzZLPc9IS5syViXF8710xLAxhZITdO3XJMnnyMW02+MQSvv8jUik8D8tW00id+LEFixcigqoqCFIuCfCRE1h1uu5+lVaLRp1tW3l7n560lHabbHYWwLx+bj/7huXee9iwke3PydanuORylq9AlccfYe8QvUUSCSwTQxCDWpVnnmb3q1zyNebNw7Iol2XLZtm2VbZsLh+uVg5NZ3e/SDrDCQsxTUvu/o0mk8zMcNMmGTmAYeB5HWHWnMmunWx5GNclk8UwqNWoVhgY5KuX0dMz2/Kk2QympqdGZkqhVQ6cj+Y82bGdPf/WsUNcfKmln1krf3oIRCplxCCO5dG/cfY5dHdrdzfr1rN6DdOTlMvEMek0ff1kM+96T8bHo8cf1Vht20qoLu6xCwM9Gsc0m/LLWzWfl/ikhfge6TSZNK0W5UrN0/Dz5yY2bDAXHI9lCXK0VcSqGs9aUMNI337Lu/POySeeGUxrxoqJY/I5LRaJItptDk9S7Jd4xSJyOaKIbIZancmpRt0fKkk1kTMLPWJbvKf9qKJHDK5hpDPT0mjMz+qCbkOSLraN7xPFxDFRNMu2xKuWEIa02p1l30dpmc7hGa8VqEademcB5Ei7E1AR2zYLx/d1xS3xPPI5CgVKJcTANBChVKbVssjnmC6BYpn4GgdhZNrJrvQC9dV2WbaCYn/H1IaBYXQQ4ph39stru+hKqLo0mjSaiNBq01/shF2jie9bBCGG0NuLbUsY1krtwKAvkdB0Rq+8igu/TCqNbeN5NOqzHAFkMjSbet3V8uxWbCeot6JGM1GvY5qYJqqEIW2POLI4PEkUUW9gWUG9ub9h9SWVcplCL+ecxwvPs20rGzZSLsuN1+P7aIyqXvFNLvgS687i709jyFTZcw0jYcUUCjg29QamQbEXPzCYO0hPgWYzqDWHpmWsKSZKpYoIjsPEuNx7Dz/ZRK1KrUqzQatNo4HvATgu4LeD0aYJkEqScEkmcR1cl3SadMpCFcsik4krjaY6fetO72ru15G3O7wLGIbUqnrKqfq7B3jwj7gJLriQvr7Ze6CeP16lHWEZkEwSRTQa1Bu4Lu02nmfQaqMx+ZzrGMuWDCz96TVusfco1xyRd/QgD90vD98vD/yBLQ/TbAJMT2kQFMxgZcHPOJBMks2QSBBGWBapFCIGqRSJBMkkjpNwTTuV0Ch6TyrqbHZxeEJefJ52m0ZDdmynVGLzg/z6doFMfz5ZLIhh4Pt4Ps0mcUQQ0GoRBAatFlHUqTeOiWPRGMtCjA6AiLyznzf36tr1uAkWLdY77mZygptuYHxMkgn6+hjol96ezpsjmWRwgGqVkVHKFYtyhWIfGqMxCAoKuSyuQxzT309XN9WK/PxniBBFOjiHXJ6nnpCxQzgOljWbP3gecYzvd8qybeKYMLRmD4Lv0/ZAO9raNtUK+4Y562z9/SCN+tFkXXACrsMXztNKhX9sk6kpJqeIY+p1HIdSCYQ4ZqCfeh0xzet7cqRT1Oo0mnR1sWw5Tz4hpRK1GkN7UMUwOhcnighDDk8wvBevjWWza6dUSup5Eiu2RTZDXy9RrLWaVGsEgV56hcSnLaFWIwx10cdRlWqF0VGyGWybUok4xjSPPkbEwLFnI5ZWW1VjxBTIZjBNDUPCSFttmWXi3PO54WaDfA6gu8D3fojjMHqQYi8D/fQWcBwSCWybMNIgJAjI5+jrpa+XfA7LVJHRplHyJa7Vo1I5rDb8RtuLaPoaLFnBNT+mUPgPxtP84xMraBYAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjUtMDgtMjJUMDg6NTU6MjkrMDA6MDAH6M/WAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDI1LTA4LTIyVDA4OjU1OjI5KzAwOjAwdrV3agAAACh0RVh0ZGF0ZTp0aW1lc3RhbXAAMjAyNS0wOC0yMlQwODo1NTo1MCswMDowML79Gn8AAAAASUVORK5CYII=">
  <style>
    :root {
      --bg: #0d1117;
      --panel: #161b22;
      --text: #e6edf3;
      --muted: #a1a1aa;
      --primary: #3b82f6;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
      --border: #2d333b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'Apple Color Emoji', 'Segoe UI Emoji';
      background: var(--bg); color: var(--text);
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
    }
    .container { max-width: 1100px; margin: 0 auto; padding: 16px; }
    @media (min-width: 768px) { .container { padding: 24px; } }
    header { 
      display: flex; 
      align-items: center; 
      justify-content: space-between; 
      gap: 8px; 
      margin-bottom: 16px;
      flex-wrap: wrap;
    }
    @media (max-width: 640px) {
      header { flex-direction: column; align-items: stretch; gap: 12px; }
      header .flex { width: 100%; justify-content: center; }
    }
    .brand { font-weight: 700; font-size: 18px; }
    @media (min-width: 768px) { .brand { font-size: 20px; } }
    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
    @media (min-width: 768px) { .panel { padding: 16px; } }
    .row { display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 960px) { .row { grid-template-columns: 1fr; } }
    button {
      background: var(--primary); border: none; color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      font-size: 13px;
    }
    @media (max-width: 640px) {
      button { padding: 8px 12px; font-size: 13px; }
    }
    button.secondary { background: #334155; }
    button.success { background: var(--success); }
    button.warning { background: var(--warning); }
    button.danger { background: var(--danger); }
    button:disabled { opacity: .6; cursor: not-allowed; }

    /* Tabs */
    .tabs { 
      display: flex; 
      gap: 8px; 
      flex-wrap: nowrap; 
      overflow-x: auto; 
      -webkit-overflow-scrolling: touch; 
      margin: 0 0 12px 0; 
      padding-bottom: 2px; 
    }
    .tabs::-webkit-scrollbar { height: 0; }
    .tabs { scrollbar-width: none; }
    .tab { background: #334155; color: #fff; border: 1px solid var(--border); padding: 6px 10px; border-radius: 999px; cursor: pointer; white-space: nowrap; }
    .tab.active { background: var(--primary); }
    input, textarea { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border); background: #0b1220; color: var(--text); }
    input[readonly] { opacity: .85; }
    label { font-size: 12px; color: var(--muted); display: inline-block; margin-bottom: 6px; }
    .muted { color: var(--muted); }
    .flex { display: flex; gap: 8px; align-items: center; }
    .between { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .list { display: grid; gap: 12px; }
    .post { border: 1px solid var(--border); border-radius: 12px; padding: 12px; background: #0f1623; }
    .post h3 { margin: 0 0 6px; font-size: 18px; }
        .tag { display: inline-block; font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); }
    .divider { height: 1px; background: var(--border); margin: 12px 0; }
    .nfts { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 12px; }
    .card { background: #0f1623; border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
    a { color: #93c5fd; text-decoration: none; }
    .small { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
    .mb8 { margin-bottom: 8px; }
    .mb12 { margin-bottom: 12px; }
    .mb16 { margin-bottom: 16px; }
    .cover { width: 100%; max-height: 260px; object-fit: cover; border-radius: 10px; border: 1px solid var(--border); display: block; }
    .avatar { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 1px solid var(--border); }
    .nft-img { width: 100%; height: 180px; object-fit: cover; border-radius: 8px; border: 1px solid var(--border); display: block; }
    .prize-img { width: 56px; height: 56px; border-radius: 8px; object-fit: cover; border: 1px solid var(--border); }
    .prize-row { display: flex; align-items: center; gap: 10px; }

    /* Hover copy tooltip */
    .hover-copy { position: relative; display: inline-flex; align-items: center; gap: 6px; }
    /* bridge area to avoid flicker when moving cursor from trigger to tooltip */
    .hover-copy::after { content: ""; position: absolute; left: 0; top: 100%; width: 100%; height: 12px; }
    .hover-copy .tooltip {
      display: none; position: absolute; top: 100%; left: 0; transform: translateY(6px); z-index: 1000;
      background: #0b1220; color: var(--text); border: 1px solid var(--border);
      padding: 8px 10px; border-radius: 8px; min-width: 240px; max-width: 360px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
      user-select: text;
    }
    /* keep visible when either trigger or tooltip is hovered */
    .hover-copy:hover .tooltip, .hover-copy .tooltip:hover { display: block; }
    .small-btn {
      background: #334155; color: #fff; border: none; padding: 3px 6px; border-radius: 6px; cursor: pointer; font-size: 11px;
      touch-action: manipulation;
    }
    /* Header/panel head tweaks for better mobile layout */
    .panel-head .right-actions { flex-wrap: wrap; gap: 8px; }
    .panel-head .network { display: flex; flex-direction: column; }

    @media (max-width: 640px) {
      header .brand { width: 100%; text-align: center; }
      .panel-head { gap: 10px; }
      .panel-head .right-actions { justify-content: flex-start; }
      .panel-head .right-actions button { flex: 1 1 auto; }
      .panel-head .network { gap: 4px; }
    }
  /* Modal */
    .modal-overlay { 
      position: fixed; 
      inset: 0; 
      background: rgba(0,0,0,0.6); 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      z-index: 2000;
      padding: 16px;
    }
    .modal { 
      background: var(--panel); 
      border: 1px solid var(--border); 
      border-radius: 12px; 
      padding: 16px; 
      width: min(720px, 100%); 
      max-height: 80vh; 
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    @media (max-width: 640px) {
      .modal-overlay { padding: 8px; }
      .modal { padding: 12px; max-height: 90vh; }
    }
    
    /* Desktop optimizations */
    @media (min-width: 1024px) {
      .container { max-width: 1280px; }
      .panel { padding: 20px; }
      .list { gap: 14px; }
      .tabs { position: static; overflow: visible; flex-wrap: wrap; margin-bottom: 16px; padding-bottom: 0; }
      .tab { padding: 6px 10px; font-size: 13px; }
      .cover { max-height: 340px; }
      .nft-img { height: 220px; }
      .nfts { grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); }
      button { padding: 8px 12px; font-size: 13px; }
      header { margin-bottom: 20px; }
      .posts-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 16px; }
      .posts-grid .post { height: 100%; display: flex; flex-direction: column; }
      .posts-grid .cover { aspect-ratio: 16 / 9; max-height: none; }
    }

    /* Mobile optimizations */
    @media (max-width: 640px) {
      .container { padding: 12px; padding-bottom: max(12px, env(safe-area-inset-bottom)); }
      .between { flex-direction: column; align-items: stretch; gap: 12px; }
      .between > * { width: 100%; }
      .between .flex { justify-content: center; }
      .flex { gap: 10px; }
      .list { gap: 10px; }
      .panel { padding: 12px; }
      .post { padding: 10px; }
      .post h3 { font-size: 16px; }
      .small { font-size: 13px; }
      .tag { font-size: 11px; padding: 2px 6px; }
      .nfts { grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); }
      .cover { max-height: 180px; }
      .avatar { width: 60px; height: 60px; }
      .nft-img { height: 130px; }
      .prize-row { gap: 8px; }
      .prize-img { width: 44px; height: 44px; }
      input, textarea { font-size: 16px; } /* Prevent zoom on iOS */
      header .flex { width: 100%; justify-content: center; }
      header .flex button { flex: 1 1 auto; }
      .hover-copy .tooltip { 
        left: 50%; 
        transform: translateX(-50%) translateY(6px); 
        min-width: 200px; 
        max-width: 280px; 
      }
      /* Sticky, scrollable tabs */
      .tabs { 
        position: sticky; 
        top: max(0px, env(safe-area-inset-top)); 
        z-index: 1500; 
        background: linear-gradient(var(--bg), var(--bg)); 
        padding: 8px 0; 
        margin: -8px 0 12px;
        border-bottom: 1px solid var(--border);
      }
      .tab { padding: 8px 12px; }
      .tabs::-webkit-scrollbar { display: none; }
      .tabs { scrollbar-width: none; }
      /* Stack and stretch actions inside lists */
      .list .flex { flex-wrap: wrap; }
      .list .flex > button { flex: 1 1 auto; }
      .list .flex > input { flex: 1 1 100%; }
    }
    
    /* Touch-friendly spacing */
    @media (pointer: coarse) {
      button { min-height: 36px; }
      .small-btn { min-height: 26px; padding: 5px 8px; }
      .tag { padding: 4px 10px; }
      /* Disable hover tooltips on touch devices */
      .hover-copy .tooltip { display: none !important; }
    }
  </style>
</head>
<body>
  <div id="app" class="container">

  <!-- Draw Records Modal -->
  <div v-if="showDrawModal" class="modal-overlay" @click.self="closeDrawRecords">
    <div class="modal">
      <div class="between mb12">
        <h3>中奖记录</h3>
        <div class="flex">
          <button class="secondary" @click="initDrawRecords" :disabled="loadingMoreDraw">刷新</button>
          <button class="secondary" @click="closeDrawRecords">关闭</button>
        </div>
      </div>
      <div class="small muted">仅显示最近检索结果（可多次打开刷新）</div>
      <div v-if="loadingMoreDraw" class="muted">加载中...</div>
      <div v-else>
      <div v-if="drawRecords.length===0" class="muted">暂无中奖记录</div>
      <div v-for="(r,idx) in drawRecords" :key="idx" class="card">
      <div>用户：<span class="mono">{{ short(r.user) }}</span></div>
      <div>奖品名称：{{ r.prizeName }}</div>
      <div>NFT ID：<span class="mono">#{{ r.tokenId }}</span><span v-if="r.uri" class="small"> · <a :href="resolveUrl(r.uri)" target="_blank">查看</a></span></div>
      <div v-if="r._imageUrl" class="mb8">
      <img :src="displayImageUrl(r._imageUrl)" alt="NFT" class="nft-img" v-if="!r._imgErr" @error="onRecordImgError(r)" referrerpolicy="no-referrer" loading="lazy" />
      </div>
      <div>时间：{{ formatTime(r.timestamp) }}</div>
      <div class="muted small" v-if="r.tx">
      <a v-if="explorerTx(r.tx)" :href="explorerTx(r.tx)" target="_blank">查看交易</a>
      <span v-else class="mono">{{ r.tx.slice(0,10) }}...</span>
      </div>
      </div>
      </div>
      <div class="between" style="margin-top:8px;">
        <button class="secondary" @click="loadMoreDrawRecords" :disabled="loadingMoreDraw || !hasMoreDraw">{{ loadingMoreDraw ? '加载中...' : (hasMoreDraw ? '加载更多' : '没有更多了') }}</button>
      </div>
    </div>
  </div>

  <!-- Rank Modal -->
  <div v-if="showRankModal" class="modal-overlay" @click.self="closeRank">
    <div class="modal">
      <div class="between mb12">
        <h3>作者排行榜</h3>
        <div class="flex">
          <button class="secondary" @click="initRank" :disabled="loadingRank">刷新</button>
          <button class="secondary" @click="closeRank">关闭</button>
        </div>
      </div>
      <div class="small muted">按发文数量降序</div>
      <div v-if="loadingRank" class="muted">加载中...</div>
      <div v-else>
        <div v-if="rankList.length===0" class="muted">暂无数据</div>
        <div v-for="(r,idx) in rankList" :key="r.address" class="card">
          <div class="between">
            <div>
              <div class="small muted">第 {{ (currentRankPage-1)*rankPageSize + idx + 1 }} 名</div>
              <div class="hover-copy">
                <span class="mono">{{ short(r.address) }}</span>
                <span class="tooltip">
                  <div class="mono mb8" style="word-break: break-all;">{{ r.address }}</div>
                  <button class="small-btn" @click="copy(r.address)">复制</button>
                  <a v-if="explorerAddr(ttTokenAddress)" :href="explorerAddr(r.address)" target="_blank" class="small">区块浏览器</a>
                </span>
              </div>
            </div>
            <div class="small">发文数量：{{ r.count }}</div>
          </div>
        </div>
      </div>
      <div class="between" style="margin-top:8px;">
        <div class="small muted">第 {{ currentRankPage }} / {{ rankTotalPages }} 页（共 {{ rankTotal }} 位作者）</div>
        <div class="flex" style="gap:6px;">
          <button class="secondary" @click="prevRank" :disabled="!hasPrevRank">上一页</button>
          <button class="secondary" @click="nextRank" :disabled="!hasNextRank">下一页</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Edit Post Modal -->
  <div v-if="showEditModal" class="modal-overlay" @click.self="closeEdit">
    <div class="modal">
      <div class="between mb12">
        <h3>编辑文章</h3>
        <div class="flex">
          <button class="secondary" @click="closeEdit">关闭</button>
        </div>
      </div>
      <div class="list">
        <div>
          <label>标题</label>
          <ime-input v-model="editingPost.title" placeholder="标题"></ime-input>
        </div>
        <div>
          <label>封面图 URL</label>
          <div class="flex">
            <ime-input v-model="editingPost.url" placeholder="https://..." style="flex:1;"></ime-input>
            <button class="secondary" @click="onUploadEditPostCover" :disabled="editPostCoverUploading">{{ editPostCoverUploading ? '上传中...' : '上传图片' }}</button>
          </div>
          <div v-if="editingPost.url" class="mb8">
            <img :src="displayImageUrl(editingPost.url)" alt="封面预览" class="cover" referrerpolicy="no-referrer" />
          </div>
        </div>
        <div>
          <label>内容（已自动解码，保存时自动 base64+gzip 上链）</label>
          <ime-textarea v-model="editingPost.content" rows="4" placeholder="内容"></ime-textarea>
        </div>
        <div class="between">
          <div class="small muted">仅作者可编辑，操作将消耗 Gas</div>
          <div class="flex">
            <button class="success" @click="submitEdit" :disabled="!account || editSubmitting">{{ editSubmitting ? '保存中...' : '保存' }}</button>
            <button class="secondary" @click="closeEdit">取消</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- View Full Content Modal -->
  <div v-if="showContentModal" class="modal-overlay" @click.self="closeContent">
    <div class="modal">
      <div class="between mb12">
        <h3>{{ contentModal.title || '全文' }}</h3>
        <div class="flex">
          <button class="secondary" @click="closeContent">关闭</button>
        </div>
      </div>
      <div class="list">
        <pre class="small" style="white-space: pre-wrap; word-break: break-word;">{{ contentModal.content }}</pre>
      </div>
    </div>
  </div>

  <!-- Create Post Modal -->
  <div v-if="showCreateModal" class="modal-overlay" @click.self="closeCreate">
    <div class="modal">
      <div class="between mb12">
        <h3>发布文章</h3>
        <div class="flex">
          <button class="secondary" @click="closeCreate">关闭</button>
        </div>
      </div>
      <div class="list">
        <div>
          <label>标题</label>
          <ime-input v-model="newPost.title" placeholder="标题"></ime-input>
        </div>
        <div>
          <label>封面图 URL</label>
          <div class="flex">
            <ime-input v-model="newPost.url" placeholder="https://..." style="flex:1;"></ime-input>
            <button class="secondary" @click="onUploadNewPostCover" :disabled="newPostCoverUploading">{{ newPostCoverUploading ? '上传中...' : '上传图片' }}</button>
          </div>
          <div v-if="newPost.url" class="mb8">
            <img :src="displayImageUrl(newPost.url)" alt="封面预览" class="cover" referrerpolicy="no-referrer" />
          </div>
        </div>
        <div>
          <label>内容（保存时自动 base64+gzip 上链；尽量简短）</label>
          <ime-textarea v-model="newPost.content" rows="4" placeholder="内容"></ime-textarea>
        </div>
        <div class="between">
          <div class="small muted">发布会消耗 Gas</div>
          <div class="flex">
            <button class="success" @click="createPost" :disabled="!account || posting">{{ posting ? '发布中...' : '发布' }}</button>
            <button class="secondary" @click="closeCreate">取消</button>
          </div>
        </div>
      </div>
    </div>
  </div>

    <header>
      <div class="flex">
          <div class="brand">区块链博客 DApp ({{ networkDesc }})</div>
      </div>

      <div class="flex" style="flex-wrap: wrap; justify-content: flex-end;">
        <div v-if="account" class="small" style="display: flex; align-items: center;">
          <span class="hover-copy">
            <span class="mono" @click="goToExplorer(account)">{{ short(account) }}</span>
            <span class="tooltip">
              <div class="mono mb8" style="word-break: break-all;">{{ account }}</div>
              <button class="small-btn" @click="copy(account)">复制</button>
              <a v-if="explorerAddr(ttTokenAddress)" :href="explorerAddr(account)" target="_blank" class="small">区块浏览器</a>
            </span>
          </span>
          <span v-if="walletMode === 'local'" class="tag" style="margin-left: 8px;">本地</span>
          <span v-else-if="walletMode === 'metamask'" class="tag" style="margin-left: 8px;">MetaMask</span>
        </div>
        <button v-if="!account" @click="openWalletModal" :disabled="connecting">{{ connecting ? '连接中...' : '连接钱包' }}</button>
        <button v-else class="secondary" @click="openWalletSettings">钱包设置</button>
        <button v-if="account" class="secondary" @click="refreshMine">刷新资料</button>
      </div>
    </header>

    <!-- Wallet Connection Modal -->
    <div v-if="showWalletModal" class="modal-overlay" @click.self="closeWalletModal">
      <div class="modal">
        <div class="between mb12">
          <h3>选择钱包连接方式</h3>
          <button class="secondary" @click="closeWalletModal">关闭</button>
        </div>
        <div class="list">
          <button @click="connectMetaMask" :disabled="connecting" style="width: 100%;">
            {{ connecting ? '连接中...' : '连接 MetaMask' }}
          </button>
          <button class="success" @click="useLocalWallet" style="width: 100%;">
            使用本地钱包
          </button>
          <div class="small muted">
            本地钱包会自动创建账户，私钥存储在浏览器中。请注意备份私钥。
          </div>
        </div>
      </div>
    </div>

    <!-- Wallet Settings Modal -->
    <div v-if="showWalletSettings" class="modal-overlay" @click.self="closeWalletSettings">
      <div class="modal">
        <div class="between mb12">
          <h3>钱包设置</h3>
          <button class="secondary" @click="closeWalletSettings">关闭</button>
        </div>
        <div class="list">
          <div>
            <label>当前钱包模式</label>
            <div class="flex">
              <span class="tag">{{ walletMode === 'local' ? '本地钱包' : 'MetaMask' }}</span>
              <button class="secondary" @click="switchWalletMode" style="margin-left: auto;">
                切换到{{ walletMode === 'local' ? ' MetaMask' : '本地钱包' }}
              </button>
            </div>
          </div>
          <div>
            <div style="display: flex; align-items: center; gap: 10px;">
              <div style="display: flex; align-items: center; gap: 5px;">
                <label>资产</label> 
                <a href="https://testnet.megaeth.com/#2" target="_blank" rel="noopener noreferrer">
                  (领取空投)
                </a>
              </div>
              <button style="display: flex; align-items: center; gap: 5px;" class="secondary" @click="refreshBalances">刷新余额</button>
            </div>
            <div class="card small" style="margin-bottom:8px;">
              <div class="between"><div>ETH</div><div class="mono">{{ ethBalance }}</div></div>
              <div class="between"><div>{{ ttSymbol }}</div><div class="mono">{{ ttBalance }}</div></div>
            </div>
          </div>
          <div v-if="walletMode === 'local'">
            <label>账户地址</label>
            <div class="mono small" style="word-break: break-all;">{{ account }}</div>
          </div>
          
          <div v-if="walletMode === 'local'">
            <label>私钥（请妥善保管）</label>
            <div class="flex">
              <input type="password" v-model="privateKeyDisplay" readonly style="flex: 1;" />
              <button class="secondary" @click="togglePrivateKey">
                {{ showPrivateKey ? '隐藏' : '显示' }}
              </button>
              <button class="secondary" @click="copyPrivateKey">复制</button>
            </div>
            <div class="small muted">⚠️ 警告：私钥是您账户的唯一凭证，请勿泄露给他人</div>
          </div>
          
          <div v-if="walletMode === 'local'">
            <label>导入私钥</label>
            <div class="flex">
              <ime-input v-model="importPrivateKey" type="password" placeholder="输入私钥（0x开头）" style="flex: 1;"></ime-input>
              <button class="warning" @click="importWallet">导入</button>
            </div>
          </div>
          
          <div v-if="walletMode === 'local'">
            <button class="danger" @click="clearLocalWallet" style="width: 100%;">
              清除本地钱包
            </button>
            <div class="small muted">清除后将无法恢复，请确保已备份私钥</div>
          </div>
          <div>
            <button class="secondary" @click="disconnect" style="width: 100%;">
              断开连接
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Redeem Modal -->
  <div v-if="showRedeemModal" class="modal-overlay" @click.self="closeRedeem">
    <div class="modal">
      <div class="between mb12">
        <h3>兑换 TT</h3>
        <div class="flex">
          <button class="secondary" @click="closeRedeem">关闭</button>
        </div>
      </div>
      <div class="list">
        <div class="small">将消耗 <strong>{{ redeemCost }}</strong> 积分，兑换 <strong>{{ redeemAmountTT }}</strong> 个 TT Token。</div>
        <div class="small muted">当前积分：{{ points }}</div>
        <div class="flex">
          <button class="success" @click="confirmRedeem" :disabled="!account || points < redeemCost || redeeming">{{ redeeming ? '兑换中...' : '确认兑换' }}</button>
          <button class="secondary" @click="closeRedeem">取消</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Draw Result Modal -->
  <div v-if="showDrawResultModal" class="modal-overlay" @click.self="closeDrawResult">
    <div class="modal">
      <div class="between mb12">
        <h3>恭喜中奖</h3>
        <button class="secondary" @click="closeDrawResult">关闭</button>
      </div>
      <div class="list">
        <div class="small">奖品：<strong>{{ drawResult.prizeName || '未知奖品' }}</strong></div>
        <div v-if="drawResult.imageUrl" class="mb8">
          <img :src="displayImageUrl(drawResult.imageUrl)" class="nft-img" alt="prize" referrerpolicy="no-referrer" />
        </div>
        <div class="small muted" v-if="drawResult.tokenId">NFT #{{ drawResult.tokenId }}</div>
        <div class="small" v-if="drawResult.uri"><a :href="resolveUrl(drawResult.uri)" target="_blank">查看元数据</a></div>
      </div>
    </div>
  </div>

    <div class="tabs">
      <button class="tab" :class="activeTab==='posts' ? 'active' : ''" @click="setActiveTab('posts')">最新文章</button>
      <button class="tab" :class="activeTab==='profile' ? 'active' : ''" @click="setActiveTab('profile')">我的资料</button>
      <button class="tab" :class="activeTab==='draw' ? 'active' : ''" @click="setActiveTab('draw')">抽奖</button>
    </div>
    <div class="row">
      <!-- 左侧：文章与互动 -->
      <div class="panel" v-if="activeTab==='posts'">

        <div class="between mb8" style="align-items: flex-start;">
          <div class="flex" style="flex-wrap: wrap; gap: 8px;"> 
            <h3 style="margin: 0;">最新文章</h3>
            <button class="success" @click="openCreate" :disabled="!account" :title="!account ? '请先连接钱包' : '发布文章'">发布</button>
            <button class="secondary" @click="openRank">排行榜</button>
            <button class="secondary" @click="loadAll">刷新数据</button>
          </div>
          <div style="display: flex; flex-direction: column; gap: 8px; align-items: flex-end;">
            <div class="flex" style="gap:6px;">
              <button class="secondary" :class="postFilter==='all' ? 'success' : 'secondary'" @click="setPostFilter('all')">全部</button>
              <button class="secondary" :class="postFilter==='mine' ? 'success' : 'secondary'" @click="setPostFilter('mine')" :disabled="!account" :title="!account ? '请先连接钱包' : '仅显示我的文章'">我的</button>
              <div class="small muted">总数: {{ postFilter==='mine' ? mineTotal : totalPosts }}</div>
            </div>
          </div>
        </div>
        <div class="list posts-grid">
          <div v-for="p in posts" :key="p.id" class="post">
            <div class="between mb8">
              <h3>{{ p.title }}</h3>
              <div class="flex">
                <span class="tag">#{{ p.id }}</span>
                <button class="secondary" v-if="account && p.author && account.toLowerCase()===p.author.toLowerCase()" @click="openEdit(p)">编辑</button>
              </div>
            </div>
            <div class="small muted mb8">
              作者:
              <span class="hover-copy">
                <span class="mono">{{ short(p.author) }}</span>
                <span class="tooltip">
                  <div class="mono mb8" style="word-break: break-all;">{{ p.author }}</div>
                  <button class="small-btn" @click="copy(p.author)">复制</button>
                  <a v-if="explorerAddr(ttTokenAddress)" :href="explorerAddr(p.author)" target="_blank" class="small">区块浏览器</a>
                </span>
              </span>
              · 评论: {{ p.commentCount }} · 互动人数: {{ p.commenterCount }}
              · {{ formatTime(p.timestamp) }}
            </div>
            <div v-if="p.url" class="mb8">
              <a :href="resolveUrl(p.url)" target="_blank">
                <img :src="displayImageUrl(p.url)" alt="封面图" class="cover" v-if="!p._imgErr" @error="onPostImgError(p)" referrerpolicy="no-referrer"/>
              </a>
              <div v-if="p._imgErr" class="small muted">无法加载图片，<a :href="resolveUrl(p.url)" target="_blank">打开链接</a></div>
            </div>
            <div class="mb12">
              <div>{{ previewText(p) }}</div>
              <div v-if="isLongContent(p)" class="small">
                <span @click="openContent(p)" style="color: var(--primary); cursor: pointer;">查看更多</span>
              </div>
            </div>

            <div class="small muted mb8">发表评论</div>
            <div class="flex mb8" style="flex-wrap: wrap; gap: 8px;">
              <ime-input v-model="p._comment" placeholder="评论内容" style="flex: 1; min-width: 150px;"></ime-input>
              <div class="flex" style="gap: 8px;">
                <button @click="comment(p)" :disabled="!account || p._commenting">{{ p._commenting ? '发送中...' : '发送' }}</button>
                <button class="secondary" @click="toggleComments(p)">{{ p._showComments? '收起' : '评论' }}</button>
              </div>
            </div>
            <div v-if="p._showComments" class="list small">
              <div class="muted">仅通过事件读取，可能需要一点时间加载</div>
              <div v-if="p._loadingComments" class="muted">加载中...</div>
              <div v-else>
                <div v-if="!p._comments || p._comments.length===0" class="muted">暂无评论</div>
                <div v-for="(c,idx) in p._comments" :key="idx" class="card">
                  <div class="small"> 
                    <span class="hover-copy">
                      <span class="mono">{{ short(c.commenter) }}</span>
                      <span class="tooltip">
                        <div class="mono mb8" style="word-break: break-all;">{{ c.commenter }}</div>
                        <button class="small-btn" @click="copy(c.commenter)">复制</button>
                        <a v-if="explorerAddr(ttTokenAddress)" :href="explorerAddr(c.commenter)" target="_blank" class="small">区块浏览器</a>
                      </span>
                    </span>
                    · {{ formatTime(c.timestamp) }}
                  </div>
                  <div>{{ c.content }}</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="between" style="margin-top:12px;">
          <div class="small muted">第 {{ currentPage }} / {{ totalPages }} 页</div>
          <div class="flex" style="gap:6px;">
            <button class="secondary" @click="prevPage" :disabled="!hasPrev">上一页</button>
            <button class="secondary" @click="nextPage" :disabled="!hasNext">下一页</button>
          </div>
        </div>
      </div>

      <!-- 右侧：个人、抽奖、NFT -->
      <div class="panel" v-if="activeTab==='profile'">
        <div class="between mb12">
          <h3>我的资料</h3>
          <div class="small muted">我的积分: {{ points }}</div>
        </div>
        <!-- 查看模式 -->
        <div v-if="!editingProfile" class="list mb16">
          <div class="flex" style="align-items:center; gap:12px;">
            <img v-if="profile.avatar && !viewAvatarErr" :src="displayImageUrl(profile.avatar)" alt="头像" class="avatar" @error="viewAvatarErr = true" referrerpolicy="no-referrer"/>
            <div v-else class="avatar" style="display:flex;align-items:center;justify-content:center;background:#111827;color:#9ca3af;">无</div>
            <div>
              <div><strong>{{ profile.nickname || '未设置昵称' }}</strong></div>
              <div class="small muted">{{ profile.bio || '未设置简介' }}</div>
            </div>
          </div>
          <div class="between">
            <div class="small muted" v-if="account">地址:
              <span class="hover-copy">
                <span class="mono">{{ short(account) }}</span>
                <span class="tooltip">
                  <div class="mono mb8" style="word-break: break-all;">{{ account }}</div>
                  <button class="small-btn" @click="copy(account)">复制</button>
                  <a v-if="explorerAddr(ttTokenAddress)" :href="explorerAddr(account)" target="_blank" class="small">区块浏览器</a>
                </span>
              </span>
            </div>
            <button class="secondary" @click="startEditProfile" :disabled="!account">编辑</button>
          </div>
        </div>
        <!-- 编辑模式 -->
        <div v-else class="list mb16">
          <div>
            <label>昵称</label>
            <ime-input v-model="editProfile.nickname" placeholder="昵称"></ime-input>
          </div>
          <div>
            <label>头像 URL</label>
            <div class="flex">
              <ime-input v-model="editProfile.avatar" placeholder="https://..." style="flex:1;"></ime-input>
              <button class="secondary" @click="onUploadAvatar" :disabled="avatarUploading">{{ avatarUploading ? '上传中...' : '上传图片' }}</button>
            </div>
            <div v-if="editProfile.avatar" class="mb8">
              <img :src="displayImageUrl(editProfile.avatar)" alt="头像预览" class="avatar" v-if="!editAvatarErr" @error="editAvatarErr = true" referrerpolicy="no-referrer"/>
              <div v-else class="small muted">头像加载失败</div>
            </div>
          </div>
          <div>
            <label>简介</label>
            <ime-input v-model="editProfile.bio" placeholder="一句话介绍"></ime-input>
          </div>
          <div class="flex">
            <button class="success" @click="saveProfile" :disabled="!account || savingProfile">{{ savingProfile ? '保存中...' : '保存' }}</button>
            <button class="secondary" @click="cancelEditProfile">取消</button>
          </div>
        </div>

        <div class="divider"></div>

        <h3 class="mb8">我的 NFT</h3>
        <div class="nfts">
          <div v-for="n in nfts" :key="n.tokenId" class="card">
            <div v-if="n.imageUrl" class="mb8"><img :src="displayImageUrl(n.imageUrl)" class="nft-img" alt="NFT" referrerpolicy="no-referrer" /></div>
            <div class="small">#{{ n.tokenId }}</div>
            <div v-if="n.metadata" class="small">
              <div class="muted">名称: {{ n.metadata.name }}</div>
              <div class="muted">描述: {{ n.metadata.description }}</div>
            </div>
          </div>
          <div v-if="nfts.length===0" class="small muted">暂无持有</div>
        </div>
      </div>

      <div class="panel" v-if="activeTab==='draw'">
        <div class="between mb8">
          <h3>抽奖</h3>
          <div class="small muted">我的积分: {{ points }}</div>
          <div class="small muted">每次消耗 {{ drawCost }} 积分</div>
        </div>
        <div class="list mb16">
          
        <div class="flex">
        <button class="warning" @click="draw" :disabled="!account || points < drawCost || loadingDraw" :title="!account ? '请先连接钱包' : (points < drawCost ? '积分不足' : '抽奖')">{{ loadingDraw ? '抽奖中...' : '抽一次' }}</button>
        <button class="success" @click="openRedeem" :disabled="!account || points < redeemCost || redeeming" :title="!account ? '请先连接钱包' : (points < redeemCost ? '积分不足' : '兑换 TT Token')">{{ redeeming ? '兑换中...' : '兑换TT' }}</button>
        <button class="secondary" @click="openDrawRecords">查看中奖记录</button>
        </div>
        
        <div class="small muted" v-if="ttTokenAddress">
          TT 合约地址:
          <span class="hover-copy">
            <span class="mono">{{ short(ttTokenAddress) }}</span>
            <span class="tooltip">
              <div class="mono mb8" style="word-break: break-all;">{{ ttTokenAddress }}</div>
              <button class="small-btn" @click="copy(ttTokenAddress)">复制</button>
              <a v-if="explorerAddr(ttTokenAddress)" :href="explorerAddr(ttTokenAddress)" target="_blank" class="small">区块浏览器</a>
            </span>
          </span>
        </div>

        <div class="small muted" v-if="account && (points < drawCost || points < redeemCost)">积分不足，需至少 {{ Math.min(drawCost, redeemCost) }} 分</div>

          <div class="small muted">奖品列表：</div>
          <div class="list">
            <div v-for="(prize,idx) in prizes" :key="idx" class="prize-row">
              <img v-if="!prize._imgErr && (prize.imageUrl || prize.uri)" :src="displayImageUrl(prize.imageUrl || prize.uri)" class="prize-img" alt="prize" @error="prize._imgErr = true" referrerpolicy="no-referrer" />
              <div class="small" style="flex:1;">
                <div>{{ prize.name }}</div>
                <div class="muted">权重: {{ prize.weight }}</div>
              </div>
            </div>
            <div v-if="prizes.length===0" class="small muted">暂无奖品</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.10.4/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vue@3.4.38/dist/vue.global.prod.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
      
  <script>
    const BLOG_ADDRESS = '0x8039fec0287b01a685c851fb0Bac0Ac81694a483';
    const BLOG_ABI = [
    {
      "anonymous": false,
      "inputs": [
        { "indexed": true,  "internalType": "address", "name": "commenter", "type": "address" },
        { "indexed": true,  "internalType": "uint256", "name": "postId",    "type": "uint256" },
        { "indexed": false, "internalType": "string",  "name": "content",   "type": "string" },
        { "indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256" }
      ],
      "name": "Comment",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        { "indexed": true,  "internalType": "address", "name": "user",      "type": "address" },
        { "indexed": false, "internalType": "uint256", "name": "tokenId",   "type": "uint256" },
        { "indexed": false, "internalType": "string",  "name": "prizeName", "type": "string" },
        { "indexed": false, "internalType": "string",  "name": "uri",       "type": "string" },
        { "indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256" }
      ],
      "name": "NFTDrawn",
      "type": "event"
    },
    { "inputs": [
        { "internalType": "string",  "name": "title",      "type": "string" },
        { "internalType": "string",  "name": "content",    "type": "string" },
        { "internalType": "string",  "name": "url",        "type": "string" }
      ],
      "name": "createPost", "outputs": [], "stateMutability": "nonpayable", "type": "function"
    },
    { "inputs": [
        { "internalType": "uint256", "name": "postId",     "type": "uint256" },
        { "internalType": "string",  "name": "newTitle",   "type": "string" },
        { "internalType": "string",  "name": "newContent", "type": "string" },
        { "internalType": "string",  "name": "newUrl",     "type": "string" }
      ],
      "name": "editPost", "outputs": [], "stateMutability": "nonpayable", "type": "function"
    },
    { "inputs": [
        { "internalType": "uint256", "name": "postId", "type": "uint256" },
        { "internalType": "string",  "name": "content", "type": "string" }
      ],
      "name": "comment", "outputs": [], "stateMutability": "nonpayable", "type": "function"
    },
    { "inputs": [
        { "internalType": "string", "name": "nickname", "type": "string" },
        { "internalType": "string", "name": "avatar",   "type": "string" },
        { "internalType": "string", "name": "bio",      "type": "string" }
      ],
      "name": "setProfile", "outputs": [], "stateMutability": "nonpayable", "type": "function"
    },
    { "inputs": [], "name": "draw",      "outputs": [], "stateMutability": "nonpayable", "type": "function" },
    { "inputs": [], "name": "redeemTT",  "outputs": [], "stateMutability": "nonpayable", "type": "function" },

    { "inputs": [ { "internalType": "address", "name": "user", "type": "address" } ],
      "name": "getUserProfile",
      "outputs": [
        { "components": [
            { "internalType": "string", "name": "nickname", "type": "string" },
            { "internalType": "string", "name": "avatar",   "type": "string" },
            { "internalType": "string", "name": "bio",      "type": "string" }
          ],
          "internalType": "struct BlogPlatform.Profile", "name": "", "type": "tuple" },
        { "internalType": "uint256", "name": "point", "type": "uint256" }
      ],
      "stateMutability": "view", "type": "function"
    },
    { "inputs": [], "name": "getTotalPosts",
      "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [], "name": "getPrizeList",
      "outputs": [ { "components": [
            { "internalType": "string",  "name": "name",   "type": "string" },
            { "internalType": "string",  "name": "uri",    "type": "string" },
            { "internalType": "uint256", "name": "weight", "type": "uint256" }
          ], "internalType": "struct BlogPlatform.Prize[]", "name": "", "type": "tuple[]" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [ { "internalType": "address", "name": "user", "type": "address" } ],
      "name": "getUserPostCount",
      "outputs": [ { "internalType": "uint256", "name": "count", "type": "uint256" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [
        { "internalType": "address", "name": "user",   "type": "address" },
        { "internalType": "uint256", "name": "offset", "type": "uint256" },
        { "internalType": "uint256", "name": "limit",  "type": "uint256" }
      ],
      "name": "getUserPosts",
      "outputs": [ { "components": [
            { "internalType": "uint256", "name": "id",            "type": "uint256" },
            { "internalType": "string",  "name": "title",         "type": "string" },
            { "internalType": "string",  "name": "content",       "type": "string" },
            { "internalType": "string",  "name": "url",           "type": "string" },
            { "internalType": "address", "name": "author",        "type": "address" },
            { "internalType": "uint256", "name": "commentCount",  "type": "uint256" },
            { "internalType": "uint256", "name": "commenterCount", "type": "uint256" },
            { "internalType": "uint256", "name": "timestamp",     "type": "uint256" }
          ], "internalType": "struct BlogPlatform.Post[]", "name": "result", "type": "tuple[]" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [
        { "internalType": "uint256", "name": "offset", "type": "uint256" },
        { "internalType": "uint256", "name": "limit",  "type": "uint256" }
      ],
      "name": "getPosts",
      "outputs": [ { "components": [
            { "internalType": "uint256", "name": "id",            "type": "uint256" },
            { "internalType": "string",  "name": "title",         "type": "string" },
            { "internalType": "string",  "name": "content",       "type": "string" },
            { "internalType": "string",  "name": "url",           "type": "string" },
            { "internalType": "address", "name": "author",        "type": "address" },
            { "internalType": "uint256", "name": "commentCount",  "type": "uint256" },
            { "internalType": "uint256", "name": "commenterCount", "type": "uint256" },
            { "internalType": "uint256", "name": "timestamp",     "type": "uint256" }
          ], "internalType": "struct BlogPlatform.Post[]", "name": "result", "type": "tuple[]" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [], "name": "getAuthorsTotal",
      "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [
        { "internalType": "uint256", "name": "offset", "type": "uint256" },
        { "internalType": "uint256", "name": "limit",  "type": "uint256" }
      ],
      "name": "getAuthorsRank",
      "outputs": [
        { "internalType": "address[]", "name": "addrs",  "type": "address[]" },
        { "internalType": "uint256[]", "name": "counts", "type": "uint256[]" }
      ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ],
      "name": "getOwnedTokens",
      "outputs": [ { "internalType": "uint256[]", "name": "", "type": "uint256[]" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ],
      "name": "tokenURI",
      "outputs": [ { "internalType": "string", "name": "", "type": "string" } ],
      "stateMutability": "view", "type": "function" },
    { "inputs": [], "name": "ttToken",
      "outputs": [ { "internalType": "contract IERC20Upgradeable", "name": "", "type": "address" } ],
      "stateMutability": "view", "type": "function" }
  ];

  // Minimal ERC20 ABI for balance/symbol/decimals queries
  const ERC20_ABI = [
    { "constant": true, "inputs": [{"name":"account","type":"address"}], "name": "balanceOf", "outputs": [{"name":"","type":"uint256"}], "type": "function", "stateMutability":"view" },
    { "constant": true, "inputs": [], "name": "decimals", "outputs": [{"name":"","type":"uint8"}], "type": "function", "stateMutability":"view" },
    { "constant": true, "inputs": [], "name": "symbol",   "outputs": [{"name":"","type":"string"}],  "type": "function", "stateMutability":"view" }
  ];

    // Target chain configuration (ensure wallet is on correct network)
    const CHAIN_RPC = 'https://carrot.megaeth.com/rpc';
    const CHAIN_explorer = 'https://web3.okx.com/zh-hans/explorer/megaeth-testnet';
    const TARGET_CHAIN_ID = 6342;
    const TARGET_CHAIN_HEX = '0x18C6'; // 6342 in hex
    const TARGET_CHAIN_PARAMS = {
      chainId: TARGET_CHAIN_HEX,
      chainName: 'MegaETH',
      nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
      rpcUrls: [CHAIN_RPC],
      blockExplorerUrls: [CHAIN_explorer]
    };

    
    const { createApp, ref, reactive, onMounted } = Vue;

    // Configurable event query constants
    const LOG_MAX_RANGE = 90000;       
    const EVENT_SEARCH_DEPTH = 500000; 
    const POST_PAGE_SIZE = 10;        
    const BLOG_DEPLOY_BLOCK = 12852339; 

    function tryDecodeContent(raw) {
      if (!raw) return raw;
      try {
        // heuristic: base64 gzip
        // decode base64 to Uint8Array -> gunzip -> to string
        const bin = atob(raw);
        const bytes = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
        const inflated = window.pako.ungzip(bytes);
        return new TextDecoder('utf-8').decode(inflated);
      } catch (e) {
        // fallback to raw
        return raw;
      }
    }

    // Encode plain text to base64+gzip for on-chain storage
    function encodeToBase64Gzip(str) {
      try {
        const bytes = new TextEncoder().encode(str);
        const gz = window.pako.gzip(bytes);
        let bin = '';
        for (let i = 0; i < gz.length; i++) bin += String.fromCharCode(gz[i]);
        return btoa(bin);
      } catch (e) {
        console.warn('encodeToBase64Gzip failed', e);
        return str; // fallback to raw if encoding fails
      }
    }

    function parseTokenMetadata(uri) {
      if (!uri) return null;
      if (uri.startsWith('data:application/json;base64,')) {
        try {
          const b64 = uri.split(',')[1];
          const txt = atob(b64);
          return JSON.parse(txt);
        } catch { return null; }
      }
      return null; // remote HTTP(S) JSON handled in loadNFTs via fetch
    }

    function ipfsToHttp(u) {
      if (!u) return u;
      if (typeof u !== 'string') return u;
      if (u.startsWith('ipfs://')) {
        let path = u.slice(7); // remove scheme
        // normalize leading ipfs/
        if (path.startsWith('ipfs/')) {
          return 'https://black-secret-spoonbill-589.mypinata.cloud/' + path;
        }
        return 'https://black-secret-spoonbill-589.mypinata.cloud/ipfs/' + path;
      }
      return u;
    }

    function resolveUrl(u) {
      if (!u) return u;
      if (u.startsWith('ipfs://')) return ipfsToHttp(u);
      return u;
    }

    async function fetchJsonSafe(u, timeoutMs = 8000) {
      const tryFetch = async (url) => {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeoutMs);
        try {
          const resp = await fetch(url, { mode: 'cors', signal: controller.signal });
          if (!resp.ok) return null;
          return await resp.json();
        } catch (_) {
          return null;
        } finally {
          clearTimeout(id);
        }
      };

      // First attempt
      let res = await tryFetch(u);
      if (res) return res;

      // If it's ipfs.io, try alternate gateways
      const gateways = ['https://cloudflare-ipfs.com', 'https://dweb.link'];
      if (typeof u === 'string' && u.startsWith('https://ipfs.io')) {
        for (const gw of gateways) {
          const alt = gw + u.slice('https://ipfs.io'.length);
          res = await tryFetch(alt);
          if (res) return res;
        }
      }
      return null;
    }

    async function resolvePrizeImage(uri) {
      if (!uri) return '';
      if (uri.startsWith('data:application/json;base64,')) {
        const md = parseTokenMetadata(uri);
        return md && md.image ? resolveUrl(md.image) : '';
      }
      if (uri.startsWith('data:image')) return uri;
      let resolved = resolveUrl(uri);
      if (/\.json(\?|#|$)/i.test(resolved)) {
        const md = await fetchJsonSafe(resolved);
        if (md && md.image) return resolveUrl(md.image);
        return '';
      }
      // try fetch as JSON anyway; if fails, assume it's direct image link
      if (/^https?:\/\//i.test(resolved)) {
        const md = await fetchJsonSafe(resolved);
        if (md && md.image) return resolveUrl(md.image);
      }
      return resolved;
    }

    // For displaying images safely under HTTPS and avoiding referer-based hotlinking
    function displayImageUrl(u) {
      if (!u || typeof u !== 'string') return u;
      // do not transform data URLs; ipfs resolved via configured gateway
      if (u.startsWith('data:')) return u;
      if (u.startsWith('ipfs://')) return resolveUrl(u);
      if (u.startsWith('http://')) {
        const noScheme = u.replace(/^https?:\/\//, '');
        return 'https://images.weserv.nl/?url=' + encodeURIComponent(noScheme);
      }
      return u;
    }

    // Calculate offset/limit for reverse-ordered pagination (newest first)
    function calcReversePagination(total, page, size) {
      total = Number(total || 0);
      size = Number(size || 0);
      if (size <= 0) return { offset: 0, limit: 0 };
      const pages = Math.max(1, Math.ceil(total / size));
      const p = Math.min(Math.max(1, Number(page || 1)), pages);
      // end is exclusive index for this page in ascending order
      const end = total - (p - 1) * size;
      const start = Math.max(0, end - size);
      const limit = Math.max(0, end - start);
      return { offset: start, limit };
    }

    // IME-safe input/textarea components to work around MetaMask in-app browser IME bugs
    const ImeInput = {
      name: 'ImeInput',
      inheritAttrs: false,
      props: { modelValue: [String, Number], type: { type: String, default: 'text' } },
      emits: ['update:modelValue'],
      setup(props, { emit, attrs }) {
        const val = Vue.ref(props.modelValue ?? '');
        const composing = Vue.ref(false);
        Vue.watch(() => props.modelValue, (v) => {
          if (!composing.value && v !== val.value) val.value = v ?? '';
        });
        const onInput = (e) => {
          val.value = e.target.value;
          if (!composing.value) emit('update:modelValue', e.target.value);
        };
        const onCompStart = () => { composing.value = true; };
        const onCompEnd = (e) => { composing.value = false; emit('update:modelValue', e.target.value); };
        return () => Vue.h('input', {
          ...attrs,
          type: props.type || 'text',
          value: val.value,
          onInput,
          onCompositionstart: onCompStart,
          onCompositionend: onCompEnd,
        });
      }
    };

    const ImeTextarea = {
      name: 'ImeTextarea',
      inheritAttrs: false,
      props: { modelValue: [String, Number] },
      emits: ['update:modelValue'],
      setup(props, { emit, attrs }) {
        const val = Vue.ref(props.modelValue ?? '');
        const composing = Vue.ref(false);
        Vue.watch(() => props.modelValue, (v) => {
          if (!composing.value && v !== val.value) val.value = v ?? '';
        });
        const onInput = (e) => {
          val.value = e.target.value;
          if (!composing.value) emit('update:modelValue', e.target.value);
        };
        const onCompStart = () => { composing.value = true; };
        const onCompEnd = (e) => { composing.value = false; emit('update:modelValue', e.target.value); };
        return () => Vue.h('textarea', {
          ...attrs,
          value: val.value,
          onInput,
          onCompositionstart: onCompStart,
          onCompositionend: onCompEnd,
        });
      }
    };

    const app = createApp({
      setup() {
        const account = ref('');
        const networkId = ref('');
        const blogAddress = ref(BLOG_ADDRESS);
        const totalPosts = ref(0);
        const posts = ref([]);
        const prizes = ref([]);
        const drawCost = ref(50);
        const redeemCost = ref(50);
        const redeemAmountTT = ref(50);
        const redeeming = ref(false);
        const showRedeemModal = ref(false);
        const showDrawResultModal = ref(false);
        const drawResult = reactive({ prizeName: '', imageUrl: '', uri: '', tokenId: null, tx: '' });
        const profile = reactive({ nickname: '', avatar: '', bio: '' });
        const points = ref(0);
        const nfts = ref([]);
        const ttTokenAddress = ref('');
        const ethBalance = ref('0');
        const ttBalance = ref('0');
        const ttSymbol = ref('TT');

        const connecting = ref(false);
        const posting = ref(false);
        const loadingDraw = ref(false);
        const savingProfile = ref(false);
                const postFilter = ref('all');
        const drawRecords = ref([]);
        // rank modal state
        const showRankModal = ref(false);
        const rankTotal = ref(0);
        const rankPageSize = ref(20);
        const currentRankPage = ref(1);
        const rankList = ref([]);
        const loadingRank = ref(false);
        const rankTotalPages = Vue.computed(() => Math.max(1, Math.ceil(Number(rankTotal.value || 0) / Number(rankPageSize.value || 1))));
        const hasPrevRank = Vue.computed(() => currentRankPage.value > 1);
        const hasNextRank = Vue.computed(() => currentRankPage.value < rankTotalPages.value);
        // pagination state
        const currentPageAll = ref(1);
        const currentPageMine = ref(1);
        const mineTotal = ref(0);
        const totalPagesAll = Vue.computed(() => Math.max(1, Math.ceil(Number(totalPosts.value || 0) / POST_PAGE_SIZE)));
        const totalPagesMine = Vue.computed(() => Math.max(1, Math.ceil(Number(mineTotal.value || 0) / POST_PAGE_SIZE)));
        const currentPage = Vue.computed(() => postFilter.value === 'mine' ? currentPageMine.value : currentPageAll.value);
        const totalPages = Vue.computed(() => postFilter.value === 'mine' ? totalPagesMine.value : totalPagesAll.value);
        const hasPrev = Vue.computed(() => currentPage.value > 1);
        const hasNext = Vue.computed(() => currentPage.value < totalPages.value);
        const showDrawModal = ref(false);
        const drawScanCursor = ref(0);
        const drawScanEnd = ref(0);
        const drawPageSize = ref(20);
        const hasMoreDraw = ref(false);
        const loadingMoreDraw = ref(false);
        const viewAvatarErr = ref(false);
        const editAvatarErr = ref(false);
        const editingProfile = ref(false);
        const editProfile = reactive({ nickname: '', avatar: '', bio: '' });
        // edit modal state
        const showEditModal = ref(false);
        const editingPost = reactive({ id: null, title: '', content: '', url: '' });
        const editSubmitting = ref(false);
        const showCreateModal = ref(false);
        const activeTab = ref('posts');
        function setActiveTab(t) { activeTab.value = t; }

        // Wallet management
        const walletMode = ref(''); // 'local' or 'metamask'
        const showWalletModal = ref(false);
        const showWalletSettings = ref(false);
        const localWallet = ref(null);
        const privateKeyDisplay = ref('');
        const showPrivateKey = ref(false);
        const importPrivateKey = ref('');

        let web3 = null;
        let contract = null;
        const hasProviderListeners = ref(false);
        let localNonces = {};
        const sendQueues = {};
        function runInQueue(addr, fn) {
          if (!sendQueues[addr]) sendQueues[addr] = Promise.resolve();
          const p = sendQueues[addr].then(() => fn());
          // 保持队列链路，即使当前任务失败
          sendQueues[addr] = p.catch(() => {});
          return p;
        }

        // Local wallet management functions
        function generateLocalWallet() {
          const wallet = web3.eth.accounts.create();
          localStorage.setItem('localWallet', JSON.stringify({
            address: wallet.address,
            privateKey: wallet.privateKey
          }));
          return wallet;
        }

        function loadLocalWallet() {
          const stored = localStorage.getItem('localWallet');
          if (stored) {
            try {
              const parsed = JSON.parse(stored);
              const wallet = web3.eth.accounts.privateKeyToAccount(parsed.privateKey);
              web3.eth.accounts.wallet.add(wallet);
              return wallet;
            } catch (e) {
              console.error('Failed to load local wallet', e);
              localStorage.removeItem('localWallet');
            }
          }
          return null;
        }

        function clearLocalWallet() {
          if (confirm('确定要清除本地钱包吗？此操作不可恢��！')) {
            localStorage.removeItem('localWallet');
            localWallet.value = null;
            account.value = '';
            walletMode.value = '';
            showWalletSettings.value = false;
            loadAll();
          }
        }

        async function importWallet() {
          if (!importPrivateKey.value) return alert('请输入私钥');
          try {
            const pk = importPrivateKey.value.trim();
            if (!pk.startsWith('0x')) {
              return alert('私钥格式错误，应以0x开头');
            }
            const wallet = web3.eth.accounts.privateKeyToAccount(pk);
            localStorage.setItem('localWallet', JSON.stringify({
              address: wallet.address,
              privateKey: wallet.privateKey
            }));
            web3.eth.accounts.wallet.clear();
            web3.eth.accounts.wallet.add(wallet);
            localWallet.value = wallet;
            account.value = wallet.address;
            walletMode.value = 'local';
            importPrivateKey.value = '';
            alert('导入成功');
            await loadAll();
          } catch (e) {
            console.error(e);
            alert('导入失败：' + (e?.message || e));
          }
        }

        function togglePrivateKey() {
          showPrivateKey.value = !showPrivateKey.value;
          if (showPrivateKey.value && localWallet.value) {
            privateKeyDisplay.value = localWallet.value.privateKey;
          } else {
            privateKeyDisplay.value = '••••••••••••••••••••••••••••••••';
          }
        }

        function copyPrivateKey() {
          if (localWallet.value) {
            copy(localWallet.value.privateKey);
          }
        }

        function openWalletModal() {
          showWalletModal.value = true;
        }

        function closeWalletModal() {
          showWalletModal.value = false;
        }

        async function openWalletSettings() {
          showWalletSettings.value = true;
          if (walletMode.value === 'local' && localWallet.value) {
            privateKeyDisplay.value = '••••••••••••••••••••••••••••••••';
            showPrivateKey.value = false;
          }
          try { await refreshBalances(); } catch (e) {}
        }

        function closeWalletSettings() {
          showWalletSettings.value = false;
          showPrivateKey.value = false;
          privateKeyDisplay.value = '';
          importPrivateKey.value = '';
        }

        async function useLocalWallet() {
          try {
            // Initialize web3 with RPC
            if (!web3) {
              web3 = new Web3(CHAIN_RPC);
            }
            
            // Load or create local wallet
            let wallet = loadLocalWallet();
            if (!wallet) {
              wallet = generateLocalWallet();
              alert('已创建新的本地钱包，请在钱包设置中备份私钥');
            }
            
            localWallet.value = wallet;
            account.value = wallet.address;
            walletMode.value = 'local';
            networkId.value = await web3.eth.getChainId();
            contract = new web3.eth.Contract(BLOG_ABI, blogAddress.value);
            
            showWalletModal.value = false;
            await loadAll();
          } catch (e) {
            console.error(e);
            alert('创建本地钱包失败: ' + (e?.message || e));
          }
        }

        async function connectMetaMask() {
          walletMode.value = 'metamask';
          showWalletModal.value = false;
          await connect();
        }

        async function switchWalletMode() {
          if (walletMode.value === 'local') {
            // Switch to MetaMask
            await connectMetaMask();
          } else {
            // Switch to local wallet
            await useLocalWallet();
          }
          closeWalletSettings();
        }

        function disconnect() {
          account.value = '';
          walletMode.value = '';
          localWallet.value = null;
          showWalletSettings.value = false;
          if (web3 && web3.eth.accounts.wallet) {
            web3.eth.accounts.wallet.clear();
          }
          loadAll();
        }

        async function sendTransactionSafe(method, from) {
          const MAX_RETRY = 10;
          let attempt = 0;
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));

          // 基于网络建议价格，稍作上浮
          let gasPrice;
          try {
            const base = await web3.eth.getGasPrice();
            gasPrice = (BigInt(base) + BigInt(web3.utils.toWei('0.02', 'gwei'))).toString();
          } catch {
            gasPrice = web3.utils.toWei('0.06', 'gwei');
          }

          // 不跳号：初始严格使用 pendingNonce，只有在收到 nonce too low 后才递增
          let useNonce = null;

          while (attempt < MAX_RETRY) {
            try {
              const pendingNonce = await web3.eth.getTransactionCount(from, 'pending').catch(async () => {
                return await web3.eth.getTransactionCount(from, 'latest');
              });
              if (useNonce === null) useNonce = pendingNonce; // 初次使用 pendingNonce

              console.log(`👉 Attempt ${attempt + 1}`);
              console.log('   pendingNonce:', pendingNonce, 'useNonce:', useNonce);

              let gasLimit;
              try { gasLimit = await method.estimateGas({ from }); }
              catch { gasLimit = 150000; }

              const tx = {
                from,
                to: contract.options.address,
                data: method.encodeABI(),
                gas: gasLimit,
                gasPrice,
                nonce: useNonce,
              };
              console.log('🚀 Sending tx:', tx);

              const signedTx = await web3.eth.accounts.signTransaction(tx, localWallet.value.privateKey);
              const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
              console.log('✅ Success:', receipt.transactionHash);
              return receipt;
            } catch (err) {
              const msg = (err && (err.message || String(err))).toLowerCase();
              console.warn('⚠️ sendTransaction error:', msg);

              if (msg.includes('nonce too low')) {
                // 仅在明确 nonce too low 时递增本地待用 nonce
                useNonce = (useNonce === null ? 0 : useNonce) + 1;
                // 指数回退：200ms, 400ms, 800ms ...
                await sleep(200 * Math.pow(2, attempt));
              } else if (msg.includes('replacement transaction underpriced') || msg.includes('underpriced')) {
                // 抬价 0.01 gwei 并退避
                try { gasPrice = (BigInt(gasPrice) + BigInt(web3.utils.toWei('0.01', 'gwei'))).toString(); } catch {}
                await sleep(200 * Math.pow(2, attempt));
              } else if (msg.includes('already known') || msg.includes('known transaction')) {
                throw err; // 交由上层处理
              } else {
                throw err;
              }
            }
            attempt++;
          }
          throw new Error('❌ Failed to send transaction after retries');
        }

        // Modified send transaction function to handle both wallet modes
        async function sendTransaction(method, from) {
          if (walletMode.value === 'local') {
            // 地址级队列，严格串行发送
            return await runInQueue(from, () => sendTransactionSafe(method, from));
          } else {
            // MetaMask 方式
            return await method.send({ from });
          }
        }

        // Ensure wallet is on the target chain (adds the chain if missing)
        async function ensureCorrectChainAfterConnect(provider = (typeof window !== 'undefined' ? window.ethereum : null)) {
          if (!provider || !provider.request) return;
          try {
            const currentHex = await provider.request({ method: 'eth_chainId' });
            if (currentHex !== TARGET_CHAIN_HEX) {
              try {
                await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: TARGET_CHAIN_HEX }] });
              } catch (switchError) {
                if (switchError && switchError.code === 4902) {
                  await provider.request({ method: 'wallet_addEthereumChain', params: [TARGET_CHAIN_PARAMS] });
                } else {
                  throw switchError;
                }
              }
            }
          } catch (e) {
            console.warn('ensureCorrectChainAfterConnect failed', e);
          }
        }

        function ensureReadOnly() {
          if (!web3) {
            let provider;
            if (walletMode.value === 'metamask' && window.ethereum) {
              provider = window.ethereum; // 仅在 MetaMask 模式下使用注入的 provider
            } else {
              provider = new Web3.providers.HttpProvider(CHAIN_RPC); // 其他情况使用直连 RPC
            }
            web3 = new Web3(provider);
          }
          if (!contract) {
            contract = new web3.eth.Contract(BLOG_ABI, blogAddress.value);
          }
        }
        // Get event ABI by name from static BLOG_ABI
        function getEventAbi(name) {
          return BLOG_ABI.find(o => o && o.type === 'event' && o.name === name);
        }

        function registerProviderListeners() {
          // 仅在 MetaMask 模式下注册 provider 监听
          if (walletMode.value !== 'metamask') return;
          if (!window.ethereum || hasProviderListeners.value) return;
          // 账户切换
          window.ethereum.on('accountsChanged', async (accs) => {
            try {
              account.value = accs && accs.length ? accs[0] : '';
              // 仅刷新与账号相关的数据，随后加载全局只读数据
              if (account.value) {
                await refreshMine();
              } else {
                // 清理本地展示
                profile.nickname = '';
                profile.avatar = '';
                profile.bio = '';
                points.value = 0;
              }
              await loadAll();
            } catch (e) { console.error('accountsChanged handler error', e); }
          });
          // 网络切换
          window.ethereum.on('chainChanged', async () => {
            try {
              // 重新实例化 provider/web3/contract
              web3 = new Web3(window.ethereum);
              contract = new web3.eth.Contract(BLOG_ABI, blogAddress.value);
              networkId.value = await web3.eth.getChainId();
              await loadAll();
            } catch (e) { console.error('chainChanged handler error', e); }
          });
          // 断开连接
          window.ethereum.on('disconnect', async () => {
            try {
              account.value = '';
              await loadAll();
            } catch (e) { console.error('disconnect handler error', e); }
          });
          hasProviderListeners.value = true;
        }

        const short = (addr) => addr ? (addr.slice(0,6) + '...' + addr.slice(-4)) : '';
        const formatTime = (ts) => {
          if (!ts) return '';
          const d = new Date(Number(ts) * 1000);
          return d.toLocaleString();
        };
        const networkDesc = Vue.computed(() => networkId.value ? `ChainId: ${networkId.value}` : '未连接');
        function explorerTx(tx) {
          const base = (Number(networkId.value) === 6342) ? CHAIN_explorer : '';
          return base ? base + '/tx/' + tx : '';
        }
        function explorerAddr(addr) {
          const base = (Number(networkId.value) === 6342) ? CHAIN_explorer : '';
          return base && addr ? base + '/address/' + addr : '';
        }

        function formatTokenAmount(raw, decimals = 18, fracDigits = 6) {
          if (!raw && raw !== 0) return '0';
          let s = String(raw);
          if (!/^[0-9]+$/.test(s)) {
            try { s = BigInt(s).toString(); } catch { return '0'; }
          }
          decimals = Number(decimals || 0);
          if (decimals <= 0) return s;
          const padded = s.padStart(decimals + 1, '0');
          const intPart = padded.slice(0, -decimals);
          let fracPart = padded.slice(-decimals);
          if (fracDigits >= 0) fracPart = fracPart.slice(0, fracDigits);
          fracPart = fracPart.replace(/0+$/, '');
          return fracPart ? intPart + '.' + fracPart : intPart;
        }

        async function refreshBalances() {
          try {
            if (!web3 || !account.value) { ethBalance.value = '0'; ttBalance.value = '0'; return; }
            // ETH
            const wei = await web3.eth.getBalance(account.value);
            const eth = web3.utils.fromWei(wei, 'ether');
            const parts = String(eth).split('.');
            ethBalance.value = parts.length === 1 ? parts[0] : (parts[0] + '.' + parts[1].slice(0,6)).replace(/\.?0+$/, '');
            // TT token
            ttBalance.value = '0';
            if (ttTokenAddress.value) {
              const erc20 = new web3.eth.Contract(ERC20_ABI, ttTokenAddress.value);
              const [bal, dec, sym] = await Promise.all([
                erc20.methods.balanceOf(account.value).call(),
                erc20.methods.decimals().call().catch(() => 18),
                erc20.methods.symbol().call().catch(() => 'TT')
              ]);
              ttSymbol.value = sym || 'TT';
              ttBalance.value = formatTokenAmount(bal, Number(dec || 18), 6);
            }
          } catch (e) {
            console.warn('refreshBalances failed', e);
          }
        }

        async function connect() {
          try {
            connecting.value = true;
            
            // Check if MetaMask is installed
            if (!window.ethereum) {
              // Check if on mobile
              const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
              
              if (isMobile) {
                // Check if in MetaMask browser
                if (!window.ethereum || !window.ethereum.isMetaMask) {
                  // Provide deep link to open in MetaMask browser
                  const currentUrl = window.location.href;
                  const hasQuery = currentUrl.includes('?');
                  const autoUrl = currentUrl + (hasQuery ? '&' : '?') + 'autoconnect=1';
                  const metamaskAppLink = `https://metamask.app.link/dapp/${autoUrl.replace(/^https?:\/\//, '')}`;
                  
                  if (confirm('需要在 MetaMask 应用中打开此页面。点击确定跳转到 MetaMask。')) {
                    window.location.replace(metamaskAppLink);
                  }
                  return;
                }
              } else {
                // Desktop without MetaMask
                if (confirm('未检测到 MetaMask 钱包。是否前往安装？')) {
                  window.open('https://metamask.io/download/', '_blank');
                }
                return;
              }
            }
            
            // MetaMask is available, proceed with connection
            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            account.value = accounts[0];

            await ensureCorrectChainAfterConnect(window.ethereum);

            web3 = new Web3(window.ethereum);
            networkId.value = await web3.eth.getChainId();
            contract = new web3.eth.Contract(BLOG_ABI, blogAddress.value);

            await loadAll();

            // listeners
            registerProviderListeners();
          } catch (e) {
            console.error(e);
            
            // Handle specific error cases
            if (e.code === 4001) {
              alert('用户拒绝了连接请求');
            } else if (e.code === -32002) {
              alert('请在 MetaMask 中确认连接请求');
            } else {
              alert('连接失败: ' + (e?.message || e));
            }
          } finally {
            connecting.value = false;
          }
        }

        
        async function refreshMine() {
          if (!contract) return;
          try {
            if (account.value) {
              const prof = await contract.methods.getUserProfile(account.value).call();
              profile.nickname = prof[0].nickname;
              profile.avatar = prof[0].avatar;
              profile.bio = prof[0].bio;
              points.value = Number(prof[1]);
            }
            await loadNFTs();
          } catch (e) {
            console.error('refreshMine error', e);
          }
        }

        async function loadAll() {
          if (!contract) return;
          try {
            // total posts
            totalPosts.value = Number(await contract.methods.getTotalPosts().call());

            
            // load posts according to filter and page
            await loadPosts();

            // load profile & points if connected
            if (account.value) {
              const prof = await contract.methods.getUserProfile(account.value).call();
              profile.nickname = prof[0].nickname;
              profile.avatar = prof[0].avatar;
              profile.bio = prof[0].bio;
              points.value = Number(prof[1]);
            }

            // prizes list
            prizes.value = (await contract.methods.getPrizeList().call()).map(p => ({
              name: p.name, uri: p.uri, weight: Number(p.weight), imageUrl: '', _imgErr: false
            }));

            await loadPrizeImages();

            // draw cost is fixed at 50 in current contract; expose constant here
            drawCost.value = 50;
            try {
              ttTokenAddress.value = await contract.methods.ttToken().call();
            } catch (e) {
              ttTokenAddress.value = '';
            }

            // my NFTs
            await loadNFTs();
          } catch (e) {
            console.error('loadAll error', e);
          }
        }

        async function loadPosts() {
          if (!contract) return;
          try {
            if (postFilter.value === 'mine') {
              if (!account.value) { posts.value = []; mineTotal.value = 0; return; }
                                          {
                const total = Number(await contract.methods.getUserPostCount(account.value).call());
                mineTotal.value = total;
                if (total <= 0) { posts.value = []; return; }
                const { offset, limit } = calcReversePagination(total, currentPageMine.value, POST_PAGE_SIZE);
                const list = limit > 0 ? await contract.methods.getUserPosts(account.value, offset, limit).call() : [];
                posts.value = (list || []).map(p => ({
                  ...p,
                  id: Number(p.id),
                  commentCount: Number(p.commentCount),
                  commenterCount: Number(p.commenterCount),
                  timestamp: Number(p.timestamp),
                  decodedContent: tryDecodeContent(p.content),
                  _comment: '', _showComments: false, _comments: [], _loadingComments: false, _imgErr: false, _commenting: false, _retried: false,
                })).reverse();
              }
            } else {
              const total = Number(totalPosts.value || 0);
              if (total <= 0) { posts.value = []; return; }
              const { offset: start, limit } = calcReversePagination(total, currentPageAll.value, POST_PAGE_SIZE);
              const list = limit > 0 ? await contract.methods.getPosts(start, limit).call() : [];
              posts.value = (list || []).map(p => ({
                ...p,
                id: Number(p.id),
                commentCount: Number(p.commentCount),
                commenterCount: Number(p.commenterCount),
                timestamp: Number(p.timestamp),
                decodedContent: tryDecodeContent(p.content),
                _comment: '', _showComments: false, _comments: [], _loadingComments: false, _imgErr: false, _commenting: false, _retried: false,
              })).reverse();
            }
          } catch (e) { console.error('loadPosts error', e); }
        }

        function setPostFilter(v) {
          postFilter.value = v;
          if (v === 'mine') { currentPageMine.value = 1; } else { currentPageAll.value = 1; }
          loadPosts();
          if (v === 'mine') {
            currentPageMine.value = 1;
            loadPosts();
          } else {
            currentPageAll.value = 1;
            loadPosts();
          }
        }

        async function createPost() {
          if (!account.value) return alert('请先连接钱包');
          if (!newPost.title || !newPost.content) return alert('标题与内容不能为空');
          try {
            posting.value = true;
            const method = contract.methods.createPost(newPost.title, encodeToBase64Gzip(newPost.content || ''), newPost.url || '');
            await sendTransaction(method, account.value);
            newPost.title = ''; newPost.content = ''; newPost.url = '';
            showCreateModal.value = false;
            await loadAll();
          } catch (e) {
            console.error(e);
            alert('发布失败: ' + (e?.message || e));
          } finally { posting.value = false; }
        }

                function openCreate() {
          if (!account.value) return alert('请先连接钱包');
          newPost.title = ''; newPost.url = ''; newPost.content = '';
          showCreateModal.value = true;
        }
        function closeCreate() {
          showCreateModal.value = false;
        }

        async function comment(p) {
          if (!account.value) return alert('请先连接钱包');
          if (!p._comment) return;
          try {
            p._commenting = true;
            const method = contract.methods.comment(p.id, p._comment);
            await sendTransaction(method, account.value);
            p._comment = '';
            await loadComments(p);
          } catch (e) {
            console.error(e);
            alert('评论失败: ' + (e?.message || e));
          } finally { p._commenting = false; }
        }

        async function toggleComments(p) {
          p._showComments = !p._showComments;
          if (p._showComments && (!p._comments || p._comments.length === 0)) {
            await loadComments(p);
          }
        }

        async function loadComments(p) {
          if (!contract || !web3) return;
          try {
            p._loadingComments = true;
            // Query past events for this postId (chunked to avoid provider max block range limits)
            const eventAbi = getEventAbi('Comment');
            const signature = web3.eth.abi.encodeEventSignature(eventAbi);
            let topicPostId = web3.utils.padLeft(web3.utils.numberToHex(p.id), 64);
            if (!topicPostId.startsWith('0x')) { topicPostId = '0x' + topicPostId; }

            // use shared constants
            const MAX_LOG_RANGE = LOG_MAX_RANGE; // less than provider max range
            const DEFAULT_SEARCH_DEPTH = EVENT_SEARCH_DEPTH; // search recent N blocks; adjustable
            const latest = await web3.eth.getBlockNumber();
            const start = Math.max(0, latest - DEFAULT_SEARCH_DEPTH);

            let logs = [];
            for (let fromBlock = start; fromBlock <= latest; ) {
              const toBlock = Math.min(latest, fromBlock + MAX_LOG_RANGE - 1);
              const chunk = await web3.eth.getPastLogs({
                fromBlock,
                toBlock,
                address: contract.options.address,
                topics: [signature, null, topicPostId]
              });
              logs = logs.concat(chunk);
              fromBlock = toBlock + 1;
            }

            const parsed = logs.map(l => web3.eth.abi.decodeLog(eventAbi.inputs, l.data, l.topics.slice(1)));
            p._comments = parsed.map(x => ({
              commenter: x.commenter,
              postId: Number(x.postId),
              content: x.content,
              timestamp: Number(x.timestamp)
            })).sort((a,b) => b.timestamp - a.timestamp);
          } catch (e) {
            console.error('loadComments error', e);
          } finally {
            p._loadingComments = false;
          }
        }

        function startEditProfile() {
          editProfile.nickname = profile.nickname;
          editProfile.avatar = profile.avatar;
          editProfile.bio = profile.bio;
          editAvatarErr.value = false;
          editingProfile.value = true;
        }

        function cancelEditProfile() {
          editingProfile.value = false;
        }

        async function saveProfile() {
          if (!account.value) return alert('请先连接钱包');
          try {
            savingProfile.value = true;
            const method = contract.methods.setProfile(editProfile.nickname||'', editProfile.avatar||'', editProfile.bio||'');
            await sendTransaction(method, account.value);
            profile.nickname = editProfile.nickname || '';
            profile.avatar = editProfile.avatar || '';
            profile.bio = editProfile.bio || '';
            editingProfile.value = false;
            viewAvatarErr.value = false;
            await loadAll();
          } catch (e) {
            console.error(e);
            alert('保存失败: ' + (e?.message || e));
          } finally { savingProfile.value = false; }
        }

        async function draw() {
          if (!account.value) return alert('请先连接钱包');
          if (points.value < drawCost.value) return alert('积分不足，无法抽奖');
          try {
            loadingDraw.value = true;
            const method = contract.methods.draw();
            const receipt = await sendTransaction(method, account.value);

            // 解析回执中的 NFTDrawn 事件
            try {
              const eventAbi = getEventAbi('NFTDrawn');
              const signature = web3.eth.abi.encodeEventSignature(eventAbi);
              const logs = (receipt && receipt.logs) || [];
              const log = logs.find(l => String(l.address).toLowerCase() === String(contract.options.address).toLowerCase() && l.topics && l.topics[0] === signature);
              if (log) {
                const d = web3.eth.abi.decodeLog(eventAbi.inputs, log.data, log.topics.slice(1));
                drawResult.prizeName = d.prizeName || '';
                drawResult.uri = d.uri || '';
                drawResult.tokenId = Number(d.tokenId || 0);
                drawResult.tx = log.transactionHash || (receipt && receipt.transactionHash) || '';
                drawResult.imageUrl = await resolvePrizeImage(drawResult.uri);
                showDrawResultModal.value = true;
              }
            } catch (err) {
              console.warn('parse draw event failed', err);
            }

            await loadAll();
            if (!showDrawResultModal.value) {
              alert('抽奖完成，检查 NFT 列表');
            }
          } catch (e) {
            console.error(e);
            alert('抽奖失败: ' + (e?.message || e));
          } finally { loadingDraw.value = false; }
        }

        function openRedeem() {
          if (!account.value) return alert('请先连接钱包');
          if (points.value < redeemCost.value) return alert('积分不足');
          showRedeemModal.value = true;
        }
        function closeRedeem() { showRedeemModal.value = false; }
        function closeDrawResult() { showDrawResultModal.value = false; }
        async function confirmRedeem() {
          if (!account.value) return alert('请先连接钱包');
          if (points.value < redeemCost.value) return alert('积分不足');
          try {
            redeeming.value = true;
            const method = contract.methods.redeemTT();
            await sendTransaction(method, account.value);
            showRedeemModal.value = false;
            await loadAll();
            alert('兑换成功，已获得 ' + redeemAmountTT.value + ' TT');
          } catch (e) {
            console.error(e);
            alert('兑换失败: ' + (e?.message || e));
          } finally { redeeming.value = false; }
        }

        // rank handlers
        async function openRank() {
          showRankModal.value = true;
          await initRank();
        }
        function closeRank() { showRankModal.value = false; }
        async function initRank() {
          try {
            ensureReadOnly();
            rankTotal.value = Number(await contract.methods.getAuthorsTotal().call());
                        currentRankPage.value = 1;
            await loadRankPage();
          } catch (e) { console.error('initRank error', e); }
        }
        async function loadRankPage() {
          ensureReadOnly();
          if (!contract || !web3) return;
          try {
            loadingRank.value = true;
            const size = Number(rankPageSize.value || 20);
            const p = Math.max(1, Number(currentRankPage.value || 1));
            const offset = (p - 1) * size;
            const limit = Math.max(0, Math.min(size, Number(rankTotal.value || 0) - offset));
            let addrs = [], counts = [];
            if (limit > 0) {
              const res = await contract.methods.getAuthorsRank(offset, limit).call();
                            if (Array.isArray(res) && res.length === 2) {
                addrs = res[0]; counts = res[1];
              } else {
                addrs = res.addrs || []; counts = res.counts || [];
              }
            }
            rankList.value = addrs.map((addr, i) => ({ address: addr, count: Number(counts[i] || 0) }));
          } catch (e) {
            console.error('loadRankPage error', e);
          } finally { loadingRank.value = false; }
        }
        function prevRank() { if (currentRankPage.value > 1) { currentRankPage.value--; loadRankPage(); } }
        function nextRank() { if (currentRankPage.value < rankTotalPages.value) { currentRankPage.value++; loadRankPage(); } }

        async function openDrawRecords() {
          showDrawModal.value = true;
          await initDrawRecords();
        }
        function closeDrawRecords() { showDrawModal.value = false; }

        async function initDrawRecords() {
          try {
            ensureReadOnly();
            drawRecords.value = [];
            const DEFAULT_SEARCH_DEPTH = EVENT_SEARCH_DEPTH; // search depth window
            const latest = await web3.eth.getBlockNumber();
            drawScanCursor.value = latest;
            // Use deploy block if provided (>0), otherwise fall back to recent window
            drawScanEnd.value = BLOG_DEPLOY_BLOCK > 0 ? BLOG_DEPLOY_BLOCK : Math.max(0, latest - DEFAULT_SEARCH_DEPTH);
            hasMoreDraw.value = true;
            await loadMoreDrawRecords();
          } catch (e) { console.error('initDrawRecords error', e); }
        }

        async function loadMoreDrawRecords() {
          ensureReadOnly();
          if (!contract || !web3) return;
          try {
            loadingMoreDraw.value = true;
            const eventAbi = getEventAbi('NFTDrawn');
            const signature = web3.eth.abi.encodeEventSignature(eventAbi);
            const MAX_LOG_RANGE = LOG_MAX_RANGE;

            let page = [];
            while (page.length < drawPageSize.value && drawScanCursor.value >= drawScanEnd.value) {
              const toBlock = drawScanCursor.value;
              const fromBlock = Math.max(drawScanEnd.value, toBlock - MAX_LOG_RANGE + 1);
              const chunk = await web3.eth.getPastLogs({ fromBlock, toBlock, address: contract.options.address, topics: [signature] });
              const parsed = chunk.map(l => {
                const d = web3.eth.abi.decodeLog(eventAbi.inputs, l.data, l.topics.slice(1));
                return { user: d.user, tokenId: Number(d.tokenId), prizeName: d.prizeName, uri: d.uri, timestamp: Number(d.timestamp), blockNumber: l.blockNumber, tx: l.transactionHash };
              }).sort((a,b) => b.blockNumber - a.blockNumber);

              for (const rec of parsed) {
                if (page.length < drawPageSize.value) page.push(rec);
              }

              drawScanCursor.value = fromBlock - 1;
            }

            // resolve image urls for each record
            const imgs = await Promise.all(page.map(r => resolvePrizeImage(r.uri)));
            for (let i = 0; i < page.length; i++) {
              page[i]._imageUrl = imgs[i] || '';
              page[i]._imgErr = false;
              page[i]._retried = false;
            }

            drawRecords.value = drawRecords.value.concat(page);
            hasMoreDraw.value = drawScanCursor.value >= drawScanEnd.value;
          } catch (e) {
            console.error('loadMoreDrawRecords error', e);
          } finally { loadingMoreDraw.value = false; }
        }

        async function loadNFTs() {
          if (!account.value || !contract) { nfts.value = []; return; }
          try {
            const tokenIds = await contract.methods.getOwnedTokens(account.value).call();
            const list = [];
            for (const tid of tokenIds) {
              const rawURI = await contract.methods.tokenURI(tid).call();
              const uriResolved = resolveUrl(rawURI);
              let metadata = parseTokenMetadata(rawURI);

              if (!metadata && uriResolved && uriResolved.startsWith('http')) {
                try {
                  const resp = await fetch(uriResolved, { mode: 'cors' });
                  if (resp.ok) {
                    metadata = await resp.json();
                  }
                } catch (err) {
                  console.warn('fetch metadata failed', uriResolved, err);
                }
              }

              let imageUrl = '';
              if (metadata && metadata.image) {
                imageUrl = resolveUrl(metadata.image);
              }

              list.push({ tokenId: Number(tid), tokenURI: rawURI, uriResolved, metadata, imageUrl });
            }
            nfts.value = list.sort((a, b) => b.tokenId - a.tokenId);
          } catch (e) { console.error('loadNFTs error', e); }
        }

        async function loadPrizeImages() {
          try {
            const arr = prizes.value || [];
            const imgs = await Promise.all(arr.map(p => resolvePrizeImage(p.uri)));
            for (let i = 0; i < arr.length; i++) {
              arr[i].imageUrl = displayImageUrl(imgs[i] || '');
              arr[i]._imgErr = false;
            }
          } catch (e) {
            console.warn('loadPrizeImages error', e);
          }
        }

        // Strip CDN style suffix like `!dp6` that may break hotlinking/proxying
        function stripImageStyle(u) {
          if (!u || typeof u !== 'string') return u;
          // keep query/hash, only strip the first '!' between path and query/hash
          const q = u.indexOf('?');
          const h = u.indexOf('#');
          const end = (q !== -1 && h !== -1) ? Math.min(q, h) : (q !== -1 ? q : (h !== -1 ? h : u.length));
          const bang = u.indexOf('!');
          if (bang !== -1 && bang < end) {
            return u.slice(0, bang) + u.slice(end);
          }
          return u;
        }

        // Fallback handler for draw record images to handle style suffix like .jpeg!dp6
        function onRecordImgError(r) {
          try {
            if (!r._retried && typeof r._imageUrl === 'string' && r._imageUrl.includes('!')) {
              const stripped = stripImageStyle(r._imageUrl);
              if (stripped && stripped !== r._imageUrl) {
                r._retried = true;
                r._imgErr = false;
                r._imageUrl = stripped;
                return;
              }
            }
          } catch (_) {}
          r._imgErr = true;
        }

        // Similar fallback for post cover images
        function onPostImgError(p) {
          try {
            if (!p._retried && typeof p.url === 'string' && p.url.includes('!')) {
              const stripped = stripImageStyle(p.url);
              if (stripped && stripped !== p.url) {
                p._retried = true;
                p._imgErr = false;
                p.url = stripped;
                return;
              }
            }
          } catch (_) {}
          p._imgErr = true;
        }

        // Edit post modal handlers
        function openEdit(p) {
          if (!account.value) return alert('请先连接钱包');
          if (!p || !p.author || account.value.toLowerCase() !== String(p.author).toLowerCase()) {
            return alert('仅作者可编辑');
          }
          editingPost.id = p.id;
          editingPost.title = p.title || '';
          editingPost.content = p.decodedContent ?? tryDecodeContent(p.content || '');
          editingPost.url = p.url || '';
          showEditModal.value = true;
        }
        function closeEdit() {
          showEditModal.value = false;
          editingPost.id = null;
          editingPost.title = '';
          editingPost.content = '';
          editingPost.url = '';
        }
        async function submitEdit() {
          if (!account.value) return alert('请先连接钱包');
          if (editingPost.id === null || editingPost.id === undefined) return alert('无效的文章');
          try {
            editSubmitting.value = true;
            const method = contract.methods.editPost(editingPost.id, editingPost.title || '', encodeToBase64Gzip(editingPost.content || ''), editingPost.url || '');
            await sendTransaction(method, account.value);
            showEditModal.value = false;
            await loadAll();
            alert('已保存');
          } catch (e) {
            console.error(e);
            alert('保存失败: ' + (e?.message || e));
          } finally {
            editSubmitting.value = false;
          }
        }

        
        function prevPage() {
          if (postFilter.value === 'mine') {
            if (currentPageMine.value > 1) { currentPageMine.value--; loadPosts(); }
          } else {
            if (currentPageAll.value > 1) { currentPageAll.value--; loadPosts(); }
          }
        }
        function nextPage() {
          if (postFilter.value === 'mine') {
            if (currentPageMine.value < totalPagesMine.value) { currentPageMine.value++; loadPosts(); }
          } else {
            if (currentPageAll.value < totalPagesAll.value) { currentPageAll.value++; loadPosts(); }
          }
        }

        const newPost = reactive({ title: '', content: '', url: '' });

        // Content preview and modal for full content
        const CONTENT_PREVIEW_LIMIT = 300;
        // Pinata image upload helpers (hardcoded API Key/Secret)
        const PINATA_API_KEY = 'fe075c3f02ea255b8554';
        const PINATA_API_SECRET = '3684de61cf124661170c31bb98d80daba9be1f69fcb5a59be38cec8e97f378aa';
        function pickLocalImage(accept = 'image/*') {
          return new Promise((resolve, reject) => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = accept;
            input.onchange = () => {
              const file = input.files && input.files[0];
              if (file) resolve(file); else reject(new Error('未选择文件'));
            };
            input.click();
          });
        }
        async function compressImageFile(file, maxW = 1280, maxH = 1280, quality = 0.85) {
          const img = document.createElement('img');
          const url = URL.createObjectURL(file);
          try {
            await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
            let { width, height } = img;
            const ratio = Math.min(1, maxW / width, maxH / height);
            const w = Math.max(1, Math.round(width * ratio));
            const h = Math.max(1, Math.round(height * ratio));
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            const blob = await new Promise((res) => canvas.toBlob(res, 'image/jpeg', quality));
            if (!blob) throw new Error('压缩失败');
            return blob;
          } finally {
            URL.revokeObjectURL(url);
          }
        }
        async function uploadImageToPinata(blob, filename = 'image.jpg') {
          if (!PINATA_API_KEY || !PINATA_API_SECRET) throw new Error('未配置 Pinata API Key/Secret');
          const form = new FormData();
          form.append('file', blob, filename);
          const resp = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
            method: 'POST',
            headers: {
              'pinata_api_key': PINATA_API_KEY,
              'pinata_secret_api_key': PINATA_API_SECRET,
            },
            body: form,
          });
          if (!resp.ok) {
            const text = await resp.text().catch(() => '');
            throw new Error('上传失败: ' + resp.status + ' ' + text);
          }
          const json = await resp.json();
          if (!json || !json.IpfsHash) throw new Error('Pinata 返回异常');
          return `https://black-secret-spoonbill-589.mypinata.cloud/ipfs/${json.IpfsHash}`;
        }
        async function chooseAndUpload(setter, uploadingRef) {
          try {
            uploadingRef.value = true;
            const file = await pickLocalImage('image/*');
            const blob = await compressImageFile(file);
            const url = await uploadImageToPinata(blob, (file && file.name) || 'image.jpg');
            setter(url);
          } catch (e) {
            console.error(e);
            alert(e?.message || String(e));
          } finally {
            uploadingRef.value = false;
          }
        }
        const avatarUploading = ref(false);
        const newPostCoverUploading = ref(false);
        const editPostCoverUploading = ref(false);
        async function onUploadAvatar() {
          await chooseAndUpload((url) => { editProfile.avatar = url; }, avatarUploading);
        }
        async function onUploadNewPostCover() {
          await chooseAndUpload((url) => { newPost.url = url; }, newPostCoverUploading);
        }
        async function onUploadEditPostCover() {
          await chooseAndUpload((url) => { editingPost.url = url; }, editPostCoverUploading);
        }
        const showContentModal = ref(false);
        const contentModal = reactive({ title: '', content: '' });
        function getFullContent(p) { return (p && (p.decodedContent ?? p.content)) || ''; }
        function isLongContent(p) { return getFullContent(p).length > CONTENT_PREVIEW_LIMIT; }
        function previewText(p) {
          const c = getFullContent(p);
          return c.length > CONTENT_PREVIEW_LIMIT ? (c.slice(0, CONTENT_PREVIEW_LIMIT) + '...') : c;
        }
        function openContent(p) {
          contentModal.title = p?.title || '';
          contentModal.content = getFullContent(p);
          showContentModal.value = true;
        }
        function closeContent() {
          showContentModal.value = false;
          contentModal.title = '';
          contentModal.content = '';
        }

        onMounted(async () => {
          // Force text keyboard for all text inputs/textarea on mobile to avoid numeric-only keyboards
          try {
            document.querySelectorAll('input, textarea').forEach(el => {
              if (el.tagName === 'INPUT') {
                const t = el.getAttribute('type');
                if (!t || t.toLowerCase() === 'text') {
                  el.setAttribute('type', 'text');
                }
              }
              el.setAttribute('inputmode', 'text');
              el.setAttribute('autocapitalize', 'none');
              el.setAttribute('autocomplete', 'off');
              el.setAttribute('autocorrect', 'off');
              el.setAttribute('spellcheck', 'false');
            });
          } catch (_) {}
          try {
            // Check if in MetaMask mobile browser
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isMetaMaskBrowser = window.ethereum && window.ethereum.isMetaMask;

            // Robust autoconnect for MetaMask mobile: wait for provider injection + user-gesture fallback
            try {
              const params = new URLSearchParams(window.location.search);
              const needAuto = params.get('autoconnect') === '1';
              if (needAuto && isMetaMaskBrowser) {
                let called = false;
                const doConnect = async () => {
                  if (called) return;
                  called = true;
                  try { await connect(); } catch (_) {}
                };
                if (!window.ethereum) {
                  // wait for provider injected
                  window.addEventListener('ethereum#initialized', doConnect, { once: true });
                  let tries = 0;
                  const it = setInterval(() => {
                    if (window.ethereum) { clearInterval(it); doConnect(); }
                    if (++tries > 120) { clearInterval(it); }
                  }, 50);
                } else {
                  setTimeout(doConnect, 0);
                }
                // Also trigger on first user interaction (some environments require gesture)
                const gesture = () => { doConnect(); window.removeEventListener('touchstart', gesture); window.removeEventListener('click', gesture); };
                window.addEventListener('touchstart', gesture, { once: true, passive: true });
                window.addEventListener('click', gesture, { once: true });
                // Clean URL
                try {
                  const url = new URL(window.location.href);
                  url.searchParams.delete('autoconnect');
                  history.replaceState({}, '', url.toString());
                } catch (_) {}
              }
            } catch (_) {}

            // If we were deep-linked into MetaMask with autoconnect flag, trigger connect once
            try {
              const params = new URLSearchParams(window.location.search);
              if (params.get('autoconnect') === '1' && isMetaMaskBrowser) {
                setTimeout(() => {
                  // remove the flag from URL to avoid repeated prompts on refresh
                  try {
                    const url = new URL(window.location.href);
                    url.searchParams.delete('autoconnect');
                    history.replaceState({}, '', url.toString());
                  } catch (_) {}
                  connect();
                }, 300);
              }
            } catch (_) {}
            
            // Always init a read-only provider (wallet or public RPC)
            ensureReadOnly();
            
            // Check for existing local wallet
            const stored = localStorage.getItem('localWallet');
            if (stored) {
              try {
                // Auto-connect local wallet
                await useLocalWallet();
              } catch (e) {
                console.error('Failed to auto-connect local wallet', e);
              }
            } else {
              // Check for MetaMask
              web3.eth.getChainId().then(id => networkId.value = id).catch(()=>{});
              if (window.ethereum) {
                registerProviderListeners();
                
                // Auto-connect if previously connected (for better mobile UX)
                if (window.ethereum.selectedAddress) {
                  walletMode.value = 'metamask';
                  connect();
                }
              }
            }
            
            loadAll();
          } catch (e) {
            console.warn('初始化失败', e);
          }
        });

        async function copy(text) {
          try {
            await navigator.clipboard.writeText(text);
            alert('已复制');
          } catch (e) {
            console.warn('clipboard failed, fallback via prompt', e);
            window.prompt('复制以下内容到剪贴板:', text);
          }
        }
        function goToExplorer(addr) {
          window.open(`${CHAIN_explorer}/address/${addr}`, "_blank");
        }

        return { account, connecting, connect, refreshMine, networkDesc, short, blogAddress,
                 // Wallet management
                 walletMode, showWalletModal, showWalletSettings, localWallet,
                 privateKeyDisplay, showPrivateKey, importPrivateKey,
                 openWalletModal, closeWalletModal, openWalletSettings, closeWalletSettings,
                 useLocalWallet, connectMetaMask, switchWalletMode, disconnect,
                 clearLocalWallet, importWallet, togglePrivateKey, copyPrivateKey,
                 newPost, createPost, totalPosts, posts, comment, toggleComments, formatTime,
                 // create modal
                 showCreateModal, openCreate, closeCreate, posting,
                 profile, points, draw, drawCost, loadingDraw, prizes, nfts, loadAll,
                 // filters
                 postFilter, setPostFilter,
                 // draws
                 drawRecords, showDrawModal, openDrawRecords, closeDrawRecords,
                 // profile view/edit
                 editingProfile, editProfile, startEditProfile, cancelEditProfile,
                 viewAvatarErr, editAvatarErr, saveProfile, savingProfile,
                 // utils
                 copy, displayImageUrl, resolveUrl, explorerTx,goToExplorer,
                 // content modal
                 showContentModal, contentModal, openContent, closeContent, previewText, isLongContent,
                 // image upload helpers
                 onUploadAvatar, onUploadNewPostCover, onUploadEditPostCover,
                 avatarUploading, newPostCoverUploading, editPostCoverUploading,
                                  // draw pagination
                 loadMoreDrawRecords, hasMoreDraw, loadingMoreDraw, drawPageSize,
                 // rank modal
                 showRankModal, openRank, closeRank, initRank, loadRankPage,
                 rankList, rankTotal, rankPageSize, currentRankPage, loadingRank, rankTotalPages, hasPrevRank, hasNextRank,
                 // image error fallback
                 onRecordImgError, onPostImgError,
                 // edit modal
                 showEditModal, editingPost, openEdit, closeEdit, submitEdit, editSubmitting,
                 // posts pagination
                 currentPage, totalPages, hasPrev, hasNext, prevPage, nextPage,
                 // tabs
                 activeTab, setActiveTab,
                 // redeem
                 showRedeemModal, openRedeem, closeRedeem, confirmRedeem, redeeming, redeemCost, redeemAmountTT, showDrawResultModal, drawResult, closeDrawResult, ttTokenAddress, explorerAddr, mineTotal, ethBalance, ttBalance, ttSymbol, refreshBalances };
      }
    });

    app.component('ime-input', ImeInput);
    app.component('ime-textarea', ImeTextarea);
    app.mount('#app');
  </script>
</body>
</html>
